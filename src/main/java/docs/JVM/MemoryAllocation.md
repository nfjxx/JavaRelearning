## JVM

### 内存分配

原则：分代分配，分代回收

1.对象优先在Eden分配

大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

Minor GC（采用复制算法）：只表示在新生代上的GC，不代表年轻代内存不足，非常频繁，一般回收速度也比较快。

2.大对象直接进入老年代

大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。

通过设置-XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配。

原因:
新生代采用复制算法回收垃圾，而复制算法导致内存即使有空间，还是需要提前进行垃圾回收获取连续空间来存放他们，同时会进行大量的内存复制，效率低。

3.长期存活的对象将进入老年代

JVM 给每个对象定义了一个对象年龄计数器,当新生代发生一次 Minor GC 后，存活下来的对象年龄 +1。 
当年龄超过一定值（默认15岁）时，就将超过该值的所有对象转移到老年代中去。

动态对象年龄判定： 
为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，
如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到要求的年龄

空间分配担保：
只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。
通过清除老年代中废弃数据来扩大老年代空闲空间，以便给新生代作担保。


4内存泄漏和内存溢出

内存溢出：实实在在的内存空间不足导致。 

内存泄漏：该释放的对象没有释放，多见于自己使用容器保存元素的情况下。
