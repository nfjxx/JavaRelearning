# JVM

## 类加载机制

### 定义

```text
   JVM将class文件字节码文件加载到内存中， 并将这些静态数据转换成方法区中的运行时数据结构，在堆(并不一定在堆中，HotSpot在方法区中)中生成一个代表
这个类的java.lang.Class 对象，作为方法区类数据的访问入口。
```

### 流程

![类加载流程](https://upload-images.jianshu.io/upload_images/13202633-3cb11d1712a9efc9.png?imageMogr2/auto-orient/strip|imageView2/2/w/739/format/webp)

#### 加载(查找和导入Class文件)

```text
   通过类的全限定名来获取定义此类的二进制字节流 
   将这个类字节流代表的静态存储结构转为方法区的运行时数据结构 
   在堆中生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口
```

#### 校验(确保被加载的类的正确性)

```text
   文件格式验证(基于字节流验证): 验证字节流是否符合Class文件格式的规范
   元数据验证(基于方法区的存储结构验证):对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求
   字节码验证(基于方法区的存储结构验证):通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
   符号引用验证(基于方法区的存储结构验证):确保解析动作能正确执行
  
   验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证
措施，以缩短虚拟机类加载的时间。
```

#### 准备(为类的静态变量分配内存，并将其初始化为默认值)

```text
   如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段 value 就会被初始化为 ConstantValue 属性所指定的值。
```

#### 解析(把类中的符号引用转换为直接引用)

```text
   将常量池内的符号引用替换为直接引用，针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用。
```

#### 初始化(对类的静态变量，静态代码块执行初始化操作)

类初始化阶段是类加载过程的最后一步，是执行类构造器 <clinit>() 方法的过程。

<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<client>方法执行之前，父类的<client>方法已经执行完毕。

初始化时机：
* 在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。
* 对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。
* 初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。
* 虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。
* 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析 结果为 REF_getStatic、REF_putStatic、
  REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。
  
### 类加载器

* 启动类加载器：加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。C++实现。
* 扩展类加载器：加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。
* 应用程序类加载器：加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包。
  如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

自顶向下尝试加载类，自底向上检查是否加载

#### 双亲委派机制

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载
请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。
在 java.lang.ClassLoader 中的 loadClass 方法中实现该过程。