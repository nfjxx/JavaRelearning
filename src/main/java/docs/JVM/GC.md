## JVM

### 垃圾回收

#### 回收对象判定

1.引用计数法

维护一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。

2.可达性分析法

所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。

GC Roots 对象：

* Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 本地方法栈中引用的对象
* 方法区中常量引用的对象
* 方法区中类静态属性引用的对象

引用类型：

* 强引用：只要强引用存在，垃圾收集器永远不会回收被引用的对象
* 软引用：有空闲内存，就可以暂时保留，当内存不足时清理掉
* 弱引用：无论内存是否充足，都会回收
* 虚引用：不影响回收

再次标记：
```java
    //伪代码
    if(obj.Override(finzlize())||jvm.transfer(finzlize())){
        //如果对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过,回收对象
        gc(obj);
    }eles{
        //将对象放置在一个名为F-Queue的队列之中,执行finalize（）方法
        F-Queue.join(obj);
        finzlize(obj);
        return obj.gcRoot? alive(obj):gc(obj);
    }
```

此对象是否有必要执行finalize()方法判断


#### 回收算法

1.标记清理(老年代)

遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。

将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。

缺点：效率低，产生大量碎片

2.复制(新生代)

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当内存用完，需要进行垃圾收集时，将存活的对象复制到另一块上面，然后将前一块内存全部清除。

优点：不会有内存碎片的问题。

缺点：内存缩小为原来的一半，浪费空间。

为了解决空间利用率问题，现代Java将内存分为新生代和老年代,比例是 1:2,其中新生代(Eden、From Survivor、To Survivor，比例是 8:1:1)

每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上

最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。

无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，部分存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。

3.标记整理(老年代)

遍历 GC Roots，然后将存活的对象标记，移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。


#### 垃圾收集器

1.Serial 垃圾收集器（单线程、新生代）

只使用一条 GC 线程，且在垃圾收集过程中停止一切用户线程，适合客户端使用。

2.ParNew 垃圾收集器（多线程、新生代）

ParNew 是 Serial 的多线程版本，由多条 GC 线程并行地进行垃圾清理，但清理过程依然需要停止一切用户线程。

追求降低用户停顿时间，适合交互式应用。

3.Parallel Scavenge 垃圾收集器（多线程、新生代、Java 1.8 默认）

追求 CPU 吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。

4.Serial Old（单线程、老年代、标记整理）

Serial Old 收集器是 Serial 的老年代版本，与 Serial 效果相似。

5.Parallel Old 垃圾收集器（多线程、老年代、标记整理、Java 1.8 默认）

Parallel Old 收集器是 Parallel Scavenge 的老年代版本，与 Parallel Scavenge 效果相似。

6.CMS 垃圾收集器（多线程、老年代、标记清理）

并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，总体上说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

![CMS流程](https://github.com/doocs/jvm/blob/main/docs/images/cms.png?raw=true)

* 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。
* 并发标记：使用多条标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。
* 重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。
* 并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。

缺点：吞吐量低 无法处理浮动垃圾，导致频繁 Full GC 使用“标记-清除”算法产生碎片空间

7.<font color = 'red'>G1 通用垃圾收集器</font>（标记整理、三色标记算法、Java 1.8 之后默认）

将堆划分为一块块独立的 Region。进行垃圾收集时，先估计每个 Region 中垃圾的数量，每次从垃圾回收价值最大的 Region 开始回收，从而获得最大的回收效率。

每个Region被标记了E、S、O和H，这些区域在逻辑上被映射为Eden，Survivor和老年代。
Humongous区域是为了那些存储超过50%标准region大小的对象而设计的，它用来专门存放巨型对象。
如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。

应用场景：
* 服务端多核CPU、JVM内存占用较大的应用（至少大于4G）
* 应用在运行过程中会产生大量内存碎片、需要经常压缩空间
* 想要更可控、可预期的GC停顿周期，防止高并发下应用雪崩现象



gc流程：

![G1GC](https://upload-images.jianshu.io/upload_images/4222138-f2c03483046ad33f.png?imageMogr2/auto-orient/strip|imageView2/2/w/743/format/webp)

* 初始标记 Initial Mark：
  负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，初始标记需要将Mutator线程(Java应用线程)暂停掉，也就是需要一个STW的时间段。
  事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为借道。 
  在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。


* 根分区扫描 Root Region Scanning：
  在初始标记暂停结束后，年轻代收集也完成了对象复制到Survivor的工作，应用线程开始活跃起来。
  为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描，同时扫描的Suvivor分区也被称为根分区。
  根分区扫描必须在下一次young gc启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。


* 并发标记 Concurrent Marking：
  和应用线程并发执行，每个并发标记线程每次只扫描一个分区，可达性分析标记出存活对象图。
  在这一阶段会处理Previous/Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。
  可开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。
  所有的标记任务必须在堆满前就完成扫描（并发标记耗时很长），如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。
  

* 存活数据计算 Live Data Accounting：
  存活数据计算是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。
  只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。
  

* 重新标记 Remark：
  重新标记是最后一个标记阶段，这个阶段也是并行执行的。
  在该阶段中，G1需要一个STW，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。
  同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。


* 清除 Cleanup：
  紧挨着重新标记阶段的清除(Clean)阶段也是STW的。Previous/Next标记位图、以及PTAMS/NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：
  RSet梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。    
  整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；
  识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。


